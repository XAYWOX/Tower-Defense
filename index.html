<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" type="image/png" href="favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Rajdhani', sans-serif;
            background-color: #050510;
            overflow: hidden;
            user-select: none;
            transition: background-color 1s ease;
            cursor: default;
        }
        
        body.targeting {
            cursor: crosshair !important;
        }

        .bg-cyber {
            background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -2;
            transition: opacity 1s ease;
        }

        .bg-inferno {
            background: radial-gradient(circle at center, #2d1b1b 0%, #0f0505 100%);
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -2;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .world-inferno .bg-cyber { opacity: 0; }
        .world-inferno .bg-inferno { opacity: 1; }
        
        .glass-panel {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.9));
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        
        h1, h2, h3, .neon-text { font-family: 'Orbitron', sans-serif; }

        .neon-text-blue {
            color: #60a5fa;
            text-shadow: 0 0 10px rgba(96, 165, 250, 0.5), 0 0 20px rgba(96, 165, 250, 0.3);
        }
        
        .neon-text-red {
            color: #f87171;
            text-shadow: 0 0 10px rgba(248, 113, 113, 0.5);
        }
        
        .neon-text-gold {
            color: #fbbf24;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5), 0 0 20px rgba(251, 191, 36, 0.3);
        }

        canvas { cursor: inherit; }

        .tower-btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.9) 0%, rgba(15, 23, 42, 1) 100%);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .tower-btn:hover:not(:disabled) {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 10px 20px -5px rgba(0, 0, 0, 0.5), 0 0 15px var(--glow-color);
            border-color: var(--glow-color);
        }

        .tower-btn.active {
            border-color: #60a5fa;
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.5), inset 0 0 20px rgba(96, 165, 250, 0.2);
            background: rgba(30, 58, 138, 0.6);
        }

        .tower-btn.locked {
            filter: grayscale(100%);
            opacity: 0.5;
            background: rgba(10, 10, 15, 0.9);
            border: 1px dashed #444;
        }

        .difficulty-btn.selected {
            background-color: #3b82f6;
            color: white;
            border-color: #60a5fa;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        .difficulty-btn {
            background-color: rgba(30, 41, 59, 0.5);
            color: #94a3b8;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        #btn-world {
            background: linear-gradient(45deg, #ff0055, #ff9900);
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
            animation: pulse-btn 2s infinite;
        }

        @keyframes pulse-btn {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); }
        }
        
        @keyframes warning-flash {
            0%, 100% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        
        .boss-warning {
            animation: warning-flash 1s infinite;
            pointer-events: none;
        }

        .tower-icon-wrapper {
            position: relative;
            width: 40px; 
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tower-icon-bg {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1), rgba(0,0,0,0.5));
            border: 1px solid rgba(255,255,255,0.1);
        }

        #towerInfoPanel {
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            transform: translateY(10px);
        }
        #towerInfoPanel.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .combat-locked {
            filter: grayscale(1) opacity(0.5);
            pointer-events: none;
            position: relative;
        }
        .combat-locked::after {
            content: "COMBAT";
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            color: red;
            font-weight: bold;
            text-shadow: 0 0 2px black;
        }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.4); }
    </style>
</head>
<body class="text-white h-screen w-screen overflow-hidden relative bg-black">

    <div class="bg-cyber"></div>
    <div class="bg-inferno"></div>
    <canvas id="bgCanvas" class="absolute inset-0 w-full h-full z-[-1]"></canvas>
    <canvas id="gameCanvas" class="absolute inset-0 w-full h-full z-0"></canvas>

    <!-- UI Overlay for Start Screen -->
    <div id="startScreen" class="fixed inset-0 bg-black/95 z-[100] flex items-center justify-center flex-col">
        <h1 class="text-7xl font-black neon-text-blue mb-4 tracking-widest">TOWER DEFENSE</h1>
        
        <button onclick="enterGame()" class="group relative px-12 py-4 bg-transparent border-2 border-blue-500 text-blue-400 font-bold font-orbitron text-xl uppercase tracking-widest hover:bg-blue-500/10 hover:shadow-[0_0_30px_rgba(59,130,246,0.5)] transition-all overflow-hidden">
            <span class="relative z-10">Initialiser Système</span>
            <div class="absolute inset-0 bg-blue-500 transform scale-x-0 group-hover:scale-x-100 transition-transform origin-left duration-500 -z-0 opacity-10"></div>
        </button>
        
        <div class="mt-12 flex gap-8 text-slate-500 font-rajdhani text-sm">
            <div class="flex flex-col items-center gap-2">
                <div class="w-12 h-12 border border-slate-700 rounded flex items-center justify-center bg-slate-900">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122"></path></svg>
                </div>
                <span>Souris</span>
            </div>
             <div class="flex flex-col items-center gap-2">
                <div class="w-12 h-12 border border-slate-700 rounded flex items-center justify-center bg-slate-900 font-bold">ESC</div>
                <span>Annuler</span>
            </div>
        </div>
    </div>

    <!-- Warning Boss -->
    <div id="bossWarning" class="fixed top-1/3 left-0 w-full text-center z-40 hidden boss-warning">
        <div class="inline-block bg-red-900/80 border-y-2 border-red-500 py-4 px-20">
            <h2 class="text-5xl font-black text-red-500 tracking-[0.2em] font-orbitron">⚠️ ALERTE BOSS ⚠️</h2>
            <p class="text-red-200 font-rajdhani text-xl mt-2 tracking-widest">SIGNATURE ÉNERGÉTIQUE MASSIVE DÉTECTÉE</p>
        </div>
    </div>

    <!-- Header Controls -->
    <div class="absolute top-4 left-4 z-50 flex gap-3">
        <button onclick="toggleOptions()" class="group bg-slate-800/80 hover:bg-blue-600 text-white p-3 rounded-full border border-blue-500/30 shadow-[0_0_15px_rgba(0,0,0,0.5)] transition-all" title="Paramètres">
            <svg class="w-6 h-6 group-hover:rotate-90 transition-transform duration-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
            </svg>
        </button>
        <button onclick="toggleArsenal()" class="group bg-blue-900/80 hover:bg-blue-500 text-white p-3 rounded-full border border-blue-400/50 shadow-[0_0_15px_rgba(59,130,246,0.3)] transition-all" title="Arsenal & Améliorations">
            <svg class="w-6 h-6 text-blue-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
        </button>
        <button onclick="toggleGoldShop()" class="group bg-yellow-900/80 hover:bg-yellow-500 text-white p-3 rounded-full border border-yellow-400/50 shadow-[0_0_15px_rgba(234,179,8,0.3)] transition-all" title="Boutique Or">
            <svg class="w-6 h-6 text-yellow-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        </button>
    </div>

    <div class="absolute top-4 right-4 z-50">
        <button id="btn-world" onclick="changeWorld()" class="hidden text-white font-bold py-3 px-6 rounded-lg font-orbitron tracking-widest uppercase transition-transform hover:scale-105 active:scale-95">
            ACCÉDER MONDE 2
        </button>
    </div>

    <!-- Stats Bar -->
    <div class="absolute top-0 w-full p-4 flex justify-between items-start z-10 pointer-events-none">
        
        <div class="glass-panel px-6 py-4 rounded-b-2xl pointer-events-auto flex items-center gap-6 border-t-0 mx-auto">
            <div class="flex flex-col items-center relative group min-w-[100px]">
                <span class="text-[10px] text-blue-300 uppercase tracking-[0.2em] font-bold mb-1">État Système</span>
                <div class="flex flex-col w-full gap-1">
                    <!-- SHIELD BAR -->
                    <div class="flex items-center gap-1 w-full">
                         <div class="w-full bg-slate-900 h-2 rounded-full overflow-hidden border border-slate-700 relative">
                             <div id="shieldBarUI" class="h-full bg-cyan-400 shadow-[0_0_10px_#22d3ee] transition-all duration-300" style="width: 0%"></div>
                         </div>
                         <span id="shieldDisplay" class="text-xs font-bold text-cyan-400 font-mono w-8 text-right">0</span>
                    </div>
                    <!-- HEALTH BAR -->
                    <div class="flex items-center gap-1 w-full">
                        <div class="w-full bg-slate-900 h-3 rounded-full overflow-hidden border border-slate-700 relative">
                             <div id="healthBarUI" class="h-full bg-red-500 shadow-[0_0_10px_#ef4444] transition-all duration-300" style="width: 100%"></div>
                        </div>
                        <span id="livesDisplay" class="text-sm font-black text-red-500 w-8 text-right">25</span>
                    </div>
                </div>
                
                <button onclick="buyShield()" class="absolute -bottom-8 bg-cyan-900/80 hover:bg-cyan-600 text-[10px] px-2 py-1 rounded border border-cyan-500/50 transition-all opacity-0 group-hover:opacity-100 flex items-center gap-1 min-w-max">
                    <span class="font-bold">BOUCLIER</span> <span id="shieldCostDisplay" class="text-yellow-300">600$</span>
                </button>
            </div>

            <div class="w-px h-10 bg-white/10"></div>

            <div class="flex flex-col items-center">
                <span class="text-[10px] text-blue-300 uppercase tracking-[0.2em] font-bold mb-1">Crédits</span>
                <div class="text-3xl font-black text-yellow-400 flex items-center gap-1" style="text-shadow: 0 0 15px rgba(250, 204, 21, 0.3);">
                    <span id="moneyDisplay">150</span>
                    <span class="text-sm font-normal text-yellow-200">$</span>
                </div>
            </div>

            <div class="w-px h-10 bg-white/10"></div>

            <div class="flex flex-col items-center">
                <span class="text-[10px] text-blue-300 uppercase tracking-[0.2em] font-bold mb-1">Restants</span>
                <div class="text-3xl font-black text-red-400" id="enemiesLeftDisplay">0</div>
            </div>

            <div class="w-px h-10 bg-white/10"></div>

            <div class="flex flex-col items-center">
                <span class="text-[10px] text-blue-300 uppercase tracking-[0.2em] font-bold mb-1">Vague</span>
                <div class="text-3xl font-black neon-text-blue" id="waveDisplay">1</div>
            </div>
        </div>

        <div class="glass-panel p-2 rounded-xl pointer-events-auto absolute right-4 top-24 flex flex-col gap-2 items-center">
            <button id="startWaveBtn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded-lg shadow-[0_0_20px_rgba(37,99,235,0.4)] transition-all transform hover:scale-105 active:scale-95 font-orbitron tracking-wider">
                LANCER
            </button>
            
            <div class="flex items-center gap-2 mt-1">
                <span class="text-[10px] font-bold uppercase tracking-wider text-blue-200">Auto</span>
                <button id="autoWaveBtn" onclick="toggleAutoWave()" class="w-10 h-5 bg-slate-700 rounded-full relative transition-colors duration-300 border border-white/10">
                    <div id="autoWaveKnob" class="absolute left-1 top-1 w-3 h-3 bg-white rounded-full transition-all duration-300 shadow-md"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Info Panel -->
    <div id="towerInfoPanel" class="absolute bottom-40 left-1/2 transform -translate-x-1/2 glass-panel p-4 rounded-xl z-30 w-80 border-l-4 border-blue-500">
        <div class="flex justify-between items-start mb-2">
            <h3 id="infoName" class="text-xl font-bold font-orbitron text-blue-200 uppercase tracking-widest">LASER</h3>
            <span id="infoType" class="text-[10px] bg-blue-900/50 px-2 py-1 rounded text-blue-300 uppercase font-mono">SINGLE</span>
        </div>
        <p id="infoDesc" class="text-sm text-gray-300 mb-4 font-rajdhani leading-tight">Tir rapide à cible unique.</p>
        
        <div class="grid grid-cols-3 gap-2 text-center">
            <div class="bg-black/30 p-1 rounded">
                <div class="text-[9px] text-gray-500 uppercase">Dégâts</div>
                <div id="infoDmg" class="text-yellow-400 font-bold font-mono">12</div>
            </div>
            <div class="bg-black/30 p-1 rounded">
                <div class="text-[9px] text-gray-500 uppercase">Portée</div>
                <div id="infoRange" class="text-blue-400 font-bold font-mono">120</div>
            </div>
            <div class="bg-black/30 p-1 rounded">
                <div class="text-[9px] text-gray-500 uppercase">Vitesse</div>
                <div id="infoSpeed" class="text-green-400 font-bold font-mono">Fast</div>
            </div>
        </div>
    </div>

    <!-- Build Menu -->
    <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 glass-panel px-6 py-4 rounded-2xl flex gap-3 z-20 items-end border-b-4 border-blue-500/20" id="buildMenu">
    </div>

    <!-- Action Menu (Upgrade/Sell) -->
    <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 glass-panel px-12 py-6 rounded-2xl hidden flex-col items-center gap-4 z-20 border-b-4 border-yellow-500/50" id="towerMenu">
        <h3 class="text-lg font-orbitron tracking-widest text-blue-300 flex items-center gap-2">
            <span id="selectedTowerName">TOUR</span> 
            <span class="text-xs bg-blue-500 text-white px-2 py-0.5 rounded" id="towerLevelBadge">Lvl 1</span>
        </h3>
        
        <div class="flex gap-3">
            <button onclick="activateOrbitalMode()" id="orbitalActionBtn" class="hidden group bg-cyan-900/50 hover:bg-cyan-600 border border-cyan-500/50 text-white font-bold py-2 px-5 rounded-lg shadow-[0_0_15px_rgba(34,211,238,0.3)] transition-all flex flex-col items-center min-w-[100px]">
                <span class="uppercase tracking-widest text-[10px] mb-1">ACTIVER</span>
                <span class="text-white font-mono text-sm" id="orbitalCostLabel">500$</span>
            </button>

            <button onclick="upgradeSelectedTower()" id="upgradeBtn" class="group bg-green-900/50 hover:bg-green-600 border border-green-500/50 text-white font-bold py-2 px-5 rounded-lg shadow-[0_0_15px_rgba(34,197,94,0.3)] transition-all flex flex-col items-center min-w-[100px]">
                <span class="uppercase tracking-widest text-[10px] mb-1">AMÉLIORER</span>
                <span class="text-yellow-400 font-mono text-sm" id="upgradeCost">100$</span>
            </button>

            <button onclick="startMoveTower()" class="bg-blue-900/50 hover:bg-blue-600 border border-blue-500/50 text-white font-bold py-2 px-5 rounded-lg transition-all flex flex-col items-center justify-center min-w-[100px]">
                <span class="uppercase tracking-widest text-[10px]">DÉPLACER</span>
                <svg class="w-4 h-4 mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
            </button>

            <button onclick="sellSelectedTower()" class="group bg-red-900/50 hover:bg-red-600 border border-red-500/50 text-white font-bold py-2 px-5 rounded-lg shadow-[0_0_15px_rgba(220,38,38,0.3)] transition-all flex flex-col items-center min-w-[100px]">
                <span class="uppercase tracking-widest text-[10px] mb-1">VENDRE</span>
                <span class="text-yellow-400 font-mono text-sm" id="sellRefundPrice">+50$</span>
            </button>
        </div>
    </div>

    <!-- Arsenal Overlay (Unlocks & Upgrades) -->
    <div id="arsenalOverlay" class="fixed inset-0 bg-black/90 backdrop-blur-md z-50 hidden flex items-center justify-center">
        <div class="glass-panel p-8 rounded-2xl w-full max-w-5xl border border-blue-500/30 shadow-[0_0_100px_rgba(37,99,235,0.1)] h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-6 border-b border-blue-500/20 pb-4">
                <div>
                    <h2 class="text-4xl font-black neon-text-blue font-orbitron tracking-widest uppercase">ARSENAL</h2>
                    <p class="text-blue-300 font-rajdhani text-sm mt-1">DÉVERROUILLAGE D'ARMEMENT & AMÉLIORATIONS TECH GLOBALES</p>
                </div>
                <button onclick="toggleArsenal()" class="text-slate-400 hover:text-white uppercase font-bold tracking-widest">FERMER</button>
            </div>
            
            <div id="arsenalGrid" class="grid grid-cols-4 gap-4 overflow-y-auto pr-2 custom-scrollbar flex-1">
                <!-- Généré par JS -->
            </div>
        </div>
    </div>

    <!-- Gold Shop Overlay -->
    <div id="goldShopOverlay" class="fixed inset-0 bg-black/90 backdrop-blur-md z-50 hidden flex items-center justify-center">
        <div class="glass-panel p-8 rounded-2xl w-full max-w-4xl border border-yellow-500/30 shadow-[0_0_100px_rgba(234,179,8,0.1)]">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-4xl font-black neon-text-gold font-orbitron tracking-widest uppercase">Boutique Or</h2>
                <button onclick="toggleGoldShop()" class="text-slate-400 hover:text-white uppercase font-bold tracking-widest">FERMER</button>
            </div>
            
            <p class="text-yellow-100/70 mb-8 font-rajdhani text-lg border-b border-yellow-500/20 pb-4">
                Achetez des licences pour débloquer des versions <strong class="text-yellow-400">GOLD</strong> de vos tours.
                <br><span class="text-sm text-yellow-500">EFFET : +50% Dégâts, +20% Portée, Apparence Dorée. (Permanent)</span>
            </p>

            <div id="goldShopGrid" class="grid grid-cols-4 gap-4 max-h-[50vh] overflow-y-auto pr-2 custom-scrollbar">
                <!-- Généré par JS -->
            </div>
        </div>
    </div>

    <!-- Options Overlay -->
    <div id="optionsOverlay" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center">
        <div class="glass-panel p-8 rounded-2xl w-full max-w-md border-t border-blue-500/50 shadow-[0_0_50px_rgba(0,0,0,0.8)]">
            <h2 class="text-3xl font-orbitron text-center mb-6 text-blue-200 uppercase tracking-widest border-b border-white/10 pb-4">Paramètres</h2>
            
            <div class="space-y-5">
                <div class="flex justify-between items-center">
                    <span class="font-rajdhani text-lg">Vitesse Simulation</span>
                    <div class="flex gap-2 bg-black/40 p-1 rounded-lg">
                        <button onclick="setGameSpeed(1)" id="speed1Btn" class="px-3 py-1 rounded bg-blue-600 text-xs font-bold transition-all">x1</button>
                        <button onclick="setGameSpeed(2)" id="speed2Btn" class="px-3 py-1 rounded hover:bg-white/10 text-xs font-bold text-gray-400 transition-all">x2</button>
                        <button onclick="setGameSpeed(5)" id="speed5Btn" class="px-3 py-1 rounded hover:bg-white/10 text-xs font-bold text-gray-400 transition-all">x5</button>
                    </div>
                </div>

                <div class="flex flex-col gap-2">
                    <span class="font-rajdhani text-lg">Difficulté</span>
                    <div class="flex gap-2 w-full">
                        <button onclick="setDifficulty(0.8)" id="diffEasyBtn" class="difficulty-btn flex-1 py-2 rounded text-xs font-bold uppercase transition-all">Facile</button>
                        <button onclick="setDifficulty(1.0)" id="diffNormalBtn" class="difficulty-btn selected flex-1 py-2 rounded text-xs font-bold uppercase transition-all">Normal</button>
                        <button onclick="setDifficulty(1.3)" id="diffHardBtn" class="difficulty-btn flex-1 py-2 rounded text-xs font-bold uppercase transition-all">Difficile</button>
                    </div>
                </div>

                <div class="flex justify-between items-center">
                    <span class="font-rajdhani text-lg">Effets</span>
                    <button onclick="toggleParticles()" id="particleBtn" class="text-green-400 font-bold text-sm tracking-widest bg-black/40 px-3 py-1 rounded">ON</button>
                </div>
                
                <div class="flex justify-between items-center">
                    <span class="font-rajdhani text-lg">Barres de Vie</span>
                    <button onclick="toggleHealthBars()" id="healthBarBtn" class="text-green-400 font-bold text-sm tracking-widest bg-black/40 px-3 py-1 rounded">ON</button>
                </div>

                <div class="h-px bg-white/10 my-4"></div>

                <button onclick="fullReset()" class="w-full border border-red-500/30 hover:bg-red-500/20 text-red-300 py-3 rounded text-sm uppercase tracking-widest transition-colors mb-2">
                    Effacer Sauvegarde
                </button>

                <button onclick="toggleOptions()" class="w-full bg-white/10 hover:bg-white/20 text-white py-4 rounded font-bold uppercase tracking-widest transition-colors">
                    Reprendre
                </button>
            </div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" class="fixed inset-0 bg-black/90 backdrop-blur-md z-[60] hidden flex items-center justify-center">
        <div class="glass-panel p-8 rounded-2xl w-full max-w-2xl border-l-4 border-yellow-500 shadow-[0_0_50px_rgba(234,179,8,0.2)] relative overflow-hidden">
            <div class="absolute top-0 right-0 w-32 h-32 bg-yellow-500/10 rounded-bl-full -mr-16 -mt-16 pointer-events-none"></div>
            
            <h2 class="text-4xl font-orbitron text-yellow-400 mb-6 tracking-widest">TUTORIEL</h2>
            
            <div id="tutorialContent" class="text-lg text-blue-100 font-rajdhani leading-relaxed min-h-[140px] mb-6">
            </div>

            <div class="flex justify-between items-center mt-8 pt-4 border-t border-white/10">
                <div class="flex gap-2" id="tutorialDots">
                </div>
                <div class="flex gap-4">
                    <button onclick="skipTutorial()" class="text-slate-400 hover:text-white uppercase text-xs font-bold tracking-widest px-4">Fermer</button>
                    <button onclick="nextTutorialStep()" id="tutoNextBtn" class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-2 px-6 rounded shadow-lg transition-all uppercase tracking-wider">
                        Suivant
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="overlay" class="fixed inset-0 bg-black/90 backdrop-blur-md z-50 hidden flex items-center justify-center">
        <div class="glass-panel p-12 rounded-3xl text-center max-w-lg w-full border border-red-500/30 shadow-[0_0_100px_rgba(220,38,38,0.2)]">
            <h2 id="overlayTitle" class="text-5xl font-black mb-2 uppercase text-white tracking-widest neon-text-red">ÉCHEC</h2>
            <div class="h-1 w-20 bg-red-500 mx-auto mb-6"></div>
            <p id="overlayMessage" class="text-blue-200 mb-10 text-xl font-rajdhani">La zone a été compromise.</p>
            <button onclick="resetGame()" class="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white font-bold py-4 px-10 rounded-full shadow-[0_0_30px_rgba(147,51,234,0.4)] transition-all hover:scale-105 uppercase tracking-widest">
                Relancer la simulation
            </button>
        </div>
    </div>

    <div id="toastContainer" class="fixed top-32 left-1/2 transform -translate-x-1/2 z-40 flex flex-col gap-2 pointer-events-none"></div>

    <script>
        let CANVAS_WIDTH = window.innerWidth;
        let CANVAS_HEIGHT = window.innerHeight;
        const STORAGE_KEY = 'neonDefenseSave_v13_Arsenal';
        
        const COLORS = {
            pathBorder: 'rgba(66, 153, 225, 0.15)',
            pathFill: 'rgba(15, 23, 42, 0.5)'
        };

        const TOWERS = {
            basic: { 
                name: "Laser", 
                cost: 50, 
                range: 120, 
                damage: 15,
                cooldown: 30, 
                color: '#00f3ff', 
                type: 'single', 
                unlockCost: 0,
                goldCost: 1000,
                description: "Tir laser rapide. Faibles dégâts, haute cadence.",
                techCost: 500
            },
            cannon: { 
                name: "Canon", 
                cost: 125,
                range: 100,
                damage: 50,
                cooldown: 80, 
                color: '#bc13fe', 
                type: 'aoe', 
                radius: 70, 
                unlockCost: 300,
                goldCost: 2000,
                description: "Obus explosifs de zone. Efficace contre les groupes.",
                techCost: 1000
            },
            vulkan: { 
                name: "Vulkan", 
                cost: 150, 
                range: 100, 
                damage: 2,
                cooldown: 5, 
                color: '#ff5500', 
                type: 'burn', 
                unlockCost: 600,
                goldCost: 2500,
                description: "Lance-flammes à haute température. Attention à la surchauffe.",
                techCost: 1500
            },
            plasma: { 
                name: "Plasma", 
                cost: 250, 
                range: 100, 
                damage: 15,
                cooldown: 60, 
                color: '#fbbf24', 
                type: 'pulse', 
                unlockCost: 800,
                goldCost: 3500,
                description: "Émet des ondes de choc énergétiques toutes les secondes.",
                techCost: 2000
            },
            sniper: { 
                name: "Sniper", 
                cost: 350, 
                range: 350, 
                damage: 160, 
                cooldown: 130, 
                color: '#10b981', 
                type: 'single', 
                unlockCost: 1200,
                goldCost: 4000,
                description: "Fusil de précision longue portée. Dégâts massifs sur cible unique.",
                techCost: 2500
            },
            bombe: {
                name: "Bombe",
                cost: 475,
                range: 150,
                damage: 120,
                cooldown: 90,
                color: '#a3e635',
                type: 'aoe',
                radius: 90,
                unlockCost: 1800,
                goldCost: 5000,
                description: "Lance-grenades lourd. Large zone d'impact.",
                techCost: 3000
            },
            minigun: { 
                name: "Minigun", 
                cost: 500, 
                range: 140, 
                damage: 4, 
                cooldown: 3, 
                color: '#f43f5e', 
                type: 'single', 
                unlockCost: 2200,
                goldCost: 5500,
                description: "Canon rotatif. Cadence de tir extrême.",
                techCost: 3500
            },
            tesla: { 
                name: "Tesla", 
                cost: 600, 
                range: 160, 
                damage: 22, 
                cooldown: 45, 
                color: '#d946ef', 
                type: 'chain', 
                unlockCost: 3000,
                goldCost: 6500,
                description: "Bobine électrique. L'éclair rebondit sur plusieurs cibles.",
                techCost: 4000
            },
            rocket: { 
                name: "Rocket", 
                cost: 700, 
                range: 240, 
                damage: 100, 
                cooldown: 100, 
                color: '#ef4444', 
                type: 'aoe', 
                radius: 100, 
                unlockCost: 4000,
                goldCost: 7500,
                description: "Batterie de missiles longue portée.",
                techCost: 4500
            },
            orbital: {
                name: "Orbital",
                cost: 800,
                range: 0,
                damage: 5000, 
                cooldown: 99999,
                color: '#00ffff',
                type: 'special',
                unlockCost: 6000,
                shotCost: 500,
                goldCost: 10000,
                description: "Satellite orbital. Tir manuel dévastateur (1 par vague).",
                techCost: 5000
            }
        };

        const canvas = document.getElementById('gameCanvas');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        const bgCanvas = document.getElementById('bgCanvas');
        bgCanvas.width = CANVAS_WIDTH;
        bgCanvas.height = CANVAS_HEIGHT;
        const bgCtx = bgCanvas.getContext('2d');
        
        let gameState = {
            money: 150,
            lives: 25, 
            shield: 0,
            shieldCost: 600,
            wave: 1,
            gameStarted: false,
            isPlaying: false,
            isGameOver: false,
            isPaused: false,
            autoWaveEnabled: false,
            volume: 0.5,
            gameSpeed: 1,
            particlesEnabled: true,
            healthBarsEnabled: true,
            difficultyMultiplier: 1.0,
            selectedTower: null, 
            selectedTowerInstance: null, 
            movingTowerInstance: null, 
            targetingMode: false,
            unlockedTowers: ['basic'],
            goldenTowers: [], 
            techLevels: {},
            enemies: [],
            towers: [],
            projectiles: [],
            particles: [],
            waveActive: false,
            waveEnemiesToSpawn: 0,
            waveSpawnTimer: 0,
            frames: 0,
            currentWorld: 1,
            worldUnlocked: false
        };

        Object.keys(TOWERS).forEach(k => gameState.techLevels[k] = 0);

        let currentTutorialStep = 0;
        const tutorialSteps = [
            { text: "Bienvenue, Commandant. Votre mission : Défendre la base contre les vagues ennemies." },
            { text: "CONSTRUCTION : Sélectionnez une tour en bas et cliquez sur la carte. ATTENTION : Les armes avancées doivent être débloquées dans l'ARSENAL." },
            { text: "ARSENAL : Utilisez le menu Arsenal (bouton bleu en haut) pour débloquer de nouvelles armes et améliorer leur technologie globale." },
            { text: "BOUCLIER : Surveillez votre barre bleue au-dessus de votre vie. C'est votre première ligne de défense." },
            { text: "STRATÉGIE : Combinez le ralentissement du Plasma avec les dégâts de zone du Canon. Utilisez le Vulkan avec parcimonie." },
            { text: "L'Orbital est puissant mais coûteux à utiliser. Bonne chance !" }
        ];

        let keyHistory = [];
        const CHEAT_CODE = "AWESOME";

        const BASE_PATH = [
            {x: 0, y: 100}, {x: 200, y: 100}, 
            {x: 200, y: 400}, {x: 450, y: 400}, 
            {x: 450, y: 150}, {x: 750, y: 150}, 
            {x: 750, y: 500}, {x: 1000, y: 500}
        ];
        let path = [];

        function calculatePath() {
            const scaleX = CANVAS_WIDTH / 1000;
            const scaleY = CANVAS_HEIGHT / 600;
            path = BASE_PATH.map(p => ({x: p.x * scaleX, y: p.y * scaleY}));
        }
        calculatePath();

        function drawBackgroundGrid() {
            bgCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (gameState.currentWorld === 2) {
                bgCtx.strokeStyle = 'rgba(255, 50, 0, 0.1)';
            } else {
                bgCtx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            }

            bgCtx.lineWidth = 1;
            const gridSize = 40;
            
            for(let x = 0; x <= CANVAS_WIDTH; x += gridSize) {
                bgCtx.beginPath(); bgCtx.moveTo(x, 0); bgCtx.lineTo(x, CANVAS_HEIGHT); bgCtx.stroke();
            }
            for(let y = 0; y <= CANVAS_HEIGHT; y += gridSize) {
                bgCtx.beginPath(); bgCtx.moveTo(0, y); bgCtx.lineTo(CANVAS_WIDTH, y); bgCtx.stroke();
            }
        }
        
        window.addEventListener('resize', () => {
            CANVAS_WIDTH = window.innerWidth;
            CANVAS_HEIGHT = window.innerHeight;
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            bgCanvas.width = CANVAS_WIDTH;
            bgCanvas.height = CANVAS_HEIGHT;
            calculatePath();
            drawBackgroundGrid();
        });

        drawBackgroundGrid();

        function enterGame() {
            document.getElementById('startScreen').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('startScreen').classList.add('hidden');
                gameState.gameStarted = true;
                if (!localStorage.getItem('neonDefenseTutorialSeenV13')) {
                    startTutorial();
                }
            }, 500);
        }

        function toggleOptions() {
            gameState.isPaused = !gameState.isPaused;
            const el = document.getElementById('optionsOverlay');
            if (gameState.isPaused) {
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        }

        function toggleArsenal() {
            const el = document.getElementById('arsenalOverlay');
            el.classList.toggle('hidden');
            initArsenal();
        }

        function initArsenal() {
            const container = document.getElementById('arsenalGrid');
            container.innerHTML = '';
            
            Object.keys(TOWERS).forEach(key => {
                const t = TOWERS[key];
                const isUnlocked = gameState.unlockedTowers.includes(key);
                const techLvl = gameState.techLevels[key] || 0;
                const techCost = Math.floor(t.techCost * (1 + techLvl * 0.5));
                const dmgBonus = techLvl * 10;
                
                const card = document.createElement('div');
                card.className = `p-4 rounded-xl border flex flex-col justify-between transition-all relative overflow-hidden group ${isUnlocked ? 'bg-slate-800/80 border-blue-500/50' : 'bg-slate-900/90 border-slate-700 grayscale'}`;
                
                let actionHtml = '';
                
                if (!isUnlocked) {
                    actionHtml = `
                        <div class="mt-4">
                            <button onclick="unlockWeapon('${key}')" class="w-full bg-blue-700 hover:bg-blue-600 text-white font-bold py-3 rounded uppercase tracking-widest border border-blue-400/30 shadow-lg">
                                DÉBLOQUER <span class="text-yellow-400 ml-1">${t.unlockCost}$</span>
                            </button>
                            <div class="text-xs text-center mt-2 text-slate-500">Requis pour construire</div>
                        </div>
                    `;
                } else {
                    actionHtml = `
                        <div class="mt-4 border-t border-white/10 pt-4">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-blue-300 font-bold text-xs uppercase">Niveau Tech: <span class="text-white text-lg">${techLvl}</span></span>
                                <span class="text-green-400 text-xs font-mono">+${dmgBonus}% DÉGÂTS</span>
                            </div>
                            <button onclick="upgradeTech('${key}')" class="w-full bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 rounded text-xs uppercase tracking-wide border border-slate-500">
                                AMÉLIORER TECH <span class="text-yellow-400 ml-1">${techCost}$</span>
                            </button>
                        </div>
                    `;
                }
                
                card.innerHTML = `
                    <div>
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-orbitron font-bold text-xl text-${isUnlocked ? 'white' : 'slate-500'} tracking-wider">${t.name.toUpperCase()}</h3>
                            ${isUnlocked ? '<span class="text-[10px] bg-green-900 text-green-400 px-2 py-0.5 rounded border border-green-500/30">DISPONIBLE</span>' : '<span class="text-[10px] bg-red-900 text-red-400 px-2 py-0.5 rounded border border-red-500/30">VERROUILLÉ</span>'}
                        </div>
                        <p class="text-slate-400 text-sm font-rajdhani leading-snug min-h-[40px]">${t.description}</p>
                        
                        <div class="grid grid-cols-2 gap-2 mt-4 text-xs font-mono text-slate-500">
                            <div>DMG: <span class="text-slate-300">${t.damage}</span></div>
                            <div>RNG: <span class="text-slate-300">${t.range}</span></div>
                            <div>SPD: <span class="text-slate-300">${t.cooldown}</span></div>
                            <div>COST: <span class="text-yellow-600">${t.cost}$</span></div>
                        </div>
                    </div>
                    ${actionHtml}
                `;
                container.appendChild(card);
            });
        }

        function unlockWeapon(type) {
            const cost = TOWERS[type].unlockCost;
            if (gameState.money >= cost) {
                gameState.money -= cost;
                gameState.unlockedTowers.push(type);
                saveGame();
                initArsenal();
                updateUI();
                initBuildMenu();
                showToast(`${TOWERS[type].name} DÉBLOQUÉ !`);
                createExplosion(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, '#00ff00', 50);
            } else {
                showToast(`Fonds insuffisants (${cost}$ requis)`);
            }
        }

        function upgradeTech(type) {
            const t = TOWERS[type];
            const techLvl = gameState.techLevels[type] || 0;
            const cost = Math.floor(t.techCost * (1 + techLvl * 0.5));
            
            if (gameState.money >= cost) {
                gameState.money -= cost;
                gameState.techLevels[type] = techLvl + 1;

                gameState.towers.forEach(tower => {
                    if (tower.type === type) tower.recalcStats();
                });

                saveGame();
                initArsenal();
                updateUI();
                showToast(`TECH ${t.name} AMÉLIORÉE (NIV ${techLvl + 1})`);
                createExplosion(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, '#00ffff', 30);
            } else {
                showToast("Fonds insuffisants !");
            }
        }

        function toggleGoldShop() {
            const el = document.getElementById('goldShopOverlay');
            el.classList.toggle('hidden');
            initGoldShop();
        }

        function initGoldShop() {
            const container = document.getElementById('goldShopGrid');
            container.innerHTML = '';

            Object.keys(TOWERS).forEach(key => {
                const t = TOWERS[key];
                const isUnlocked = gameState.unlockedTowers.includes(key);
                const isGold = gameState.goldenTowers.includes(key);
                
                const card = document.createElement('div');
                card.className = `p-4 rounded-xl border flex flex-col items-center gap-2 transition-all ${isGold ? 'bg-yellow-900/40 border-yellow-400' : 'bg-slate-800/50 border-slate-600'}`;
                
                if (!isUnlocked) {
                    card.classList.add('opacity-50', 'grayscale');
                    card.innerHTML = `<div class="text-xs text-center font-bold">VERROUILLÉ<br>Débloquez d'abord l'arme</div>`;
                } else if (isGold) {
                     card.innerHTML = `
                        <div class="text-yellow-400 font-bold tracking-wider">${t.name.toUpperCase()}</div>
                        <div class="text-[10px] bg-yellow-400 text-black px-2 rounded font-bold">ACQUIS</div>
                        <div class="text-[10px] text-center text-yellow-200 mt-1">Dégâts +50%<br>Portée +20%</div>
                     `;
                } else {
                     card.innerHTML = `
                        <div class="text-white font-bold tracking-wider">${t.name.toUpperCase()}</div>
                        <button onclick="buyGoldUpgrade('${key}')" class="mt-2 bg-yellow-600 hover:bg-yellow-500 text-white text-xs font-bold py-2 px-4 rounded w-full border border-yellow-400/50">
                            ACHETER ${t.goldCost}$
                        </button>
                        <div class="text-[10px] text-center text-gray-400 mt-1">Dégâts +50%<br>Portée +20%</div>
                     `;
                }
                container.appendChild(card);
            });
        }

        function buyGoldUpgrade(type) {
            const cost = TOWERS[type].goldCost;
            if (gameState.money >= cost) {
                gameState.money -= cost;
                gameState.goldenTowers.push(type);

                gameState.towers.forEach(t => {
                    if (t.type === type) {
                        t.applyGoldStats();
                    }
                });
                
                saveGame();
                updateUI();
                initGoldShop();
                showToast(`${TOWERS[type].name} VERSION OR DÉBLOQUÉE !`);
                createExplosion(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, '#FFD700', 100);
            } else {
                showToast("Fonds insuffisants !");
            }
        }

        function toggleAutoWave() {
            gameState.autoWaveEnabled = !gameState.autoWaveEnabled;
            const knob = document.getElementById('autoWaveKnob');
            const btn = document.getElementById('autoWaveBtn');
            
            if (gameState.autoWaveEnabled) {
                knob.style.left = '1.25rem'; 
                knob.classList.remove('bg-white');
                knob.classList.add('bg-green-400');
                btn.classList.add('bg-slate-600');
                showToast("MODE AUTO ACTIVÉ");
            } else {
                knob.style.left = '0.25rem'; 
                knob.classList.add('bg-white');
                knob.classList.remove('bg-green-400');
                btn.classList.remove('bg-slate-600');
            }
        }

        function startTutorial() {
            currentTutorialStep = 0;
            gameState.isPaused = true;
            document.getElementById('tutorialOverlay').classList.remove('hidden');
            updateTutorialUI();
        }

        function nextTutorialStep() {
            currentTutorialStep++;
            if (currentTutorialStep >= tutorialSteps.length) {
                skipTutorial();
            } else {
                updateTutorialUI();
            }
        }

        function skipTutorial() {
            document.getElementById('tutorialOverlay').classList.add('hidden');
            gameState.isPaused = false;
            localStorage.setItem('neonDefenseTutorialSeenV13', 'true');
        }

        function updateTutorialUI() {
            const content = document.getElementById('tutorialContent');
            content.innerHTML = tutorialSteps[currentTutorialStep].text;
            
            const dotsContainer = document.getElementById('tutorialDots');
            dotsContainer.innerHTML = '';
            for(let i=0; i<tutorialSteps.length; i++) {
                const dot = document.createElement('span');
                if (i === currentTutorialStep) {
                    dot.className = "w-3 h-3 rounded-full bg-yellow-500 scale-125 transition-all";
                } else if (i < currentTutorialStep) {
                    dot.className = "w-3 h-3 rounded-full bg-yellow-900 transition-all";
                } else {
                    dot.className = "w-3 h-3 rounded-full bg-slate-700 transition-all";
                }
                dotsContainer.appendChild(dot);
            }
            const nextBtn = document.getElementById('tutoNextBtn');
            nextBtn.innerText = currentTutorialStep === tutorialSteps.length - 1 ? "JOUER" : "SUIVANT";
        }

        function setGameSpeed(speed) {
            gameState.gameSpeed = speed;
            document.getElementById('speed1Btn').className = "px-3 py-1 rounded hover:bg-white/10 text-xs font-bold text-gray-400 transition-all";
            document.getElementById('speed2Btn').className = "px-3 py-1 rounded hover:bg-white/10 text-xs font-bold text-gray-400 transition-all";
            document.getElementById('speed5Btn').className = "px-3 py-1 rounded hover:bg-white/10 text-xs font-bold text-gray-400 transition-all";
            
            if(speed === 1) document.getElementById('speed1Btn').className = "px-3 py-1 rounded bg-blue-600 text-xs font-bold transition-all";
            if(speed === 2) document.getElementById('speed2Btn').className = "px-3 py-1 rounded bg-blue-600 text-xs font-bold transition-all";
            if(speed === 5) document.getElementById('speed5Btn').className = "px-3 py-1 rounded bg-blue-600 text-xs font-bold transition-all";
        }

        function toggleParticles() {
            gameState.particlesEnabled = !gameState.particlesEnabled;
            const btn = document.getElementById('particleBtn');
            if(gameState.particlesEnabled) {
                btn.innerText = "ON"; btn.className = "text-green-400 font-bold text-sm tracking-widest bg-black/40 px-3 py-1 rounded";
            } else {
                btn.innerText = "OFF"; btn.className = "text-red-400 font-bold text-sm tracking-widest bg-black/40 px-3 py-1 rounded";
            }
        }

        function toggleHealthBars() {
            gameState.healthBarsEnabled = !gameState.healthBarsEnabled;
            const btn = document.getElementById('healthBarBtn');
            if(gameState.healthBarsEnabled) {
                btn.innerText = "ON"; btn.className = "text-green-400 font-bold text-sm tracking-widest bg-black/40 px-3 py-1 rounded";
            } else {
                btn.innerText = "OFF"; btn.className = "text-red-400 font-bold text-sm tracking-widest bg-black/40 px-3 py-1 rounded";
            }
        }

        function setDifficulty(mult) {
            gameState.difficultyMultiplier = mult;
            document.getElementById('diffEasyBtn').classList.remove('selected');
            document.getElementById('diffNormalBtn').classList.remove('selected');
            document.getElementById('diffHardBtn').classList.remove('selected');

            if(mult === 0.8) document.getElementById('diffEasyBtn').classList.add('selected');
            if(mult === 1.0) document.getElementById('diffNormalBtn').classList.add('selected');
            if(mult === 1.3) document.getElementById('diffHardBtn').classList.add('selected');
            
            saveGame();
            showToast(`Difficulté ajustée`);
        }

        function buyShield() {
            if (gameState.money >= gameState.shieldCost) {
                gameState.money -= gameState.shieldCost;
                gameState.shield += 10;
                gameState.shieldCost *= 2;
                showToast("BOUCLIER RENFORCÉ (+10)");
                createExplosion(CANVAS_WIDTH/2, 50, '#00ffff', 40);
                updateUI();
                saveGame();
            } else {
                showToast(`Fonds insuffisants (${gameState.shieldCost}$ requis)`);
            }
        }

        function saveGame() {
            if (gameState.isGameOver) return;
            const saveState = {
                money: gameState.money,
                lives: gameState.lives,
                shield: gameState.shield,
                shieldCost: gameState.shieldCost,
                wave: gameState.wave,
                unlockedTowers: gameState.unlockedTowers,
                goldenTowers: gameState.goldenTowers,
                techLevels: gameState.techLevels,
                difficulty: gameState.difficultyMultiplier,
                worldUnlocked: gameState.worldUnlocked,
                currentWorld: gameState.currentWorld,
                autoWaveEnabled: gameState.autoWaveEnabled,
                volume: gameState.volume,
                towers: gameState.towers.map(t => ({
                    x: t.x, 
                    y: t.y, 
                    type: t.type,
                    level: t.level,
                    stats: t.stats,
                    totalSpent: t.totalSpent,
                    heat: t.heat,
                    ammo: t.ammo
                }))
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(saveState));
        }

        function loadGame() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    gameState.money = parsed.money || 150;
                    gameState.lives = parsed.lives || 25;
                    gameState.shield = parsed.shield || 0;
                    gameState.shieldCost = parsed.shieldCost || 600;
                    gameState.wave = parsed.wave || 1;
                    gameState.difficultyMultiplier = parsed.difficulty || 1.0;
                    gameState.unlockedTowers = parsed.unlockedTowers || ['basic'];
                    gameState.goldenTowers = parsed.goldenTowers || [];
                    gameState.techLevels = parsed.techLevels || {};
                    Object.keys(TOWERS).forEach(k => { if(typeof gameState.techLevels[k] === 'undefined') gameState.techLevels[k] = 0; });

                    gameState.worldUnlocked = parsed.worldUnlocked || false;
                    gameState.currentWorld = parsed.currentWorld || 1;
                    gameState.autoWaveEnabled = parsed.autoWaveEnabled || false;
                    gameState.volume = parsed.volume !== undefined ? parsed.volume : 0.5;
                    
                    if (gameState.autoWaveEnabled) toggleAutoWave();
                    document.querySelector('input[type=range]').value = gameState.volume * 100;
                    setDifficulty(gameState.difficultyMultiplier);

                    if(gameState.currentWorld === 2) {
                        document.body.classList.add('world-inferno');
                    }
                    
                    if (parsed.towers && Array.isArray(parsed.towers)) {
                        gameState.towers = parsed.towers.map(t => {
                            const newTower = new Tower(t.x, t.y, t.type);
                            if(t.level) newTower.level = t.level;
                            newTower.recalcStats(); 
                            if(t.totalSpent) newTower.totalSpent = t.totalSpent;
                            if(t.heat) newTower.heat = t.heat;
                            if(t.ammo !== undefined) newTower.ammo = t.ammo;
                            return newTower;
                        });
                    }
                    showToast("PROGRESSION RESTAURÉE");
                } catch (e) {
                    console.error("Erreur de chargement", e);
                    localStorage.removeItem(STORAGE_KEY);
                }
            }
        }

        function fullReset() {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        }

        function changeWorld() {
            gameState.currentWorld = 2;
            gameState.wave = 1; 
            document.body.classList.add('world-inferno');
            saveGame();
            updateUI();
            drawBackgroundGrid();
            showToast("BIENVENUE DANS LE MONDE 2");
            createExplosion(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, '#ff0000', 100);
        }

        class Enemy {
            constructor(wave, forcedType = null) {
                this.wpIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                
                let isBoss = false;
                let isSpeeder = false;
                let isTank = false;
                let isTitan = false; 
                let isWraith = false; 
                let isMagma = false; 
                let isInferno = false;

                if (forcedType) {
                    if (forcedType === 'boss') isBoss = true;
                    if (forcedType === 'speeder') isSpeeder = true;
                    if (forcedType === 'tank') isTank = true;
                    if (forcedType === 'titan') isTitan = true;
                    if (forcedType === 'wraith') isWraith = true;
                } else {
                    isBoss = (wave % 5 === 0);
                    if (!isBoss) {
                        if (gameState.currentWorld === 2) {
                            const rand = Math.random();
                            if (rand < 0.15) isTitan = true;
                            else if (rand < 0.35) isWraith = true;
                            else if (rand < 0.55) isMagma = true; 
                            else if (rand < 0.7) isInferno = true;
                            else if (rand < 0.8) isTank = true;
                            else isSpeeder = true;
                        } else {
                            if (wave >= 8 && Math.random() < 0.3) isSpeeder = true;
                            if (wave >= 12 && !isSpeeder && Math.random() < 0.2) isTank = true;
                        }
                    }
                }

                this.isBoss = isBoss;
                this.isSpeeder = isSpeeder;
                this.isTank = isTank;
                this.isTitan = isTitan;
                this.isWraith = isWraith;
                this.isMagma = isMagma;
                this.isInferno = isInferno;
                
                this.slowTimer = 0;
                this.burnTimer = 0;

                let baseHp = 25 + (wave * 20) + (wave * wave * 2); 
                
                this.maxHealth = baseHp * gameState.difficultyMultiplier;
                this.baseSpeed = 1 + (wave * 0.05);
                this.radius = 12;
                this.color = '#ff9900';

                if (this.isSpeeder) {
                    this.maxHealth *= 0.5;
                    this.baseSpeed *= 1.8;
                    this.radius = 9;
                    this.color = '#00ffff';
                } else if (this.isTank) {
                    this.maxHealth *= 2.5;
                    this.baseSpeed *= 0.7;
                    this.radius = 16;
                    this.color = '#22c55e';
                } else if (this.isBoss) {
                    this.maxHealth *= 5.0;
                    this.baseSpeed *= 0.5;
                    this.radius = 24;
                    this.color = '#ff0055';
                } else if (this.isTitan) {
                    this.maxHealth *= 8.0; 
                    this.baseSpeed *= 0.4; 
                    this.radius = 22;
                    this.color = '#888888';
                } else if (this.isWraith) {
                    this.maxHealth *= 0.8; 
                    this.baseSpeed *= 2.2; 
                    this.radius = 10;
                    this.color = '#a855f7';
                } else if (this.isMagma) {
                    this.maxHealth *= 3.0;
                    this.baseSpeed *= 0.6;
                    this.radius = 18;
                    this.color = '#ea580c'; 
                } else if (this.isInferno) {
                    this.maxHealth *= 1.5;
                    this.baseSpeed *= 1.2;
                    this.radius = 14;
                    this.color = '#fcd34d'; 
                }

                if(gameState.currentWorld === 2 && !this.isTitan && !this.isWraith && !this.isMagma && !this.isInferno) {
                    this.maxHealth *= 1.5; 
                }

                this.health = this.maxHealth;
                this.speed = this.baseSpeed;
                this.angle = 0;
            }

            update() {
                if (this.slowTimer > 0) {
                    this.speed = this.baseSpeed * 0.5;
                    this.slowTimer--;
                } else {
                    this.speed = this.baseSpeed;
                }

                if (this.burnTimer > 0) {
                    if (!this.isMagma && !this.isInferno) {
                        this.health -= (this.maxHealth * 0.005) + 2; 
                    }
                    this.burnTimer--;
                    if(gameState.frames % 10 === 0) createExplosion(this.x, this.y, '#ff5500', 1);
                }

                const target = path[this.wpIndex + 1];
                if (!target) return true;
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.hypot(dx, dy);
                
                this.angle = Math.atan2(dy, dx);

                if (dist < this.speed) {
                    this.x = target.x;
                    this.y = target.y;
                    this.wpIndex++;
                    if (this.wpIndex >= path.length - 1) return true;
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.shadowBlur = this.isBoss ? 20 : 10;
                ctx.shadowColor = this.color;
                
                if (this.isSpeeder) {
                    ctx.fillStyle = '#0f172a';
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(10, 0); ctx.lineTo(-8, 6); ctx.lineTo(-4, 0); ctx.lineTo(-8, -6);
                    ctx.closePath();
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = this.color; ctx.fillRect(-8, -2, 4, 4);
                } else if (this.isTank) {
                    ctx.fillStyle = '#0f172a';
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.fillRect(-12, -12, 24, 24);
                    ctx.strokeRect(-12, -12, 24, 24);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-6, -6, 12, 12);
                } else if (this.isTitan) {
                    ctx.fillStyle = '#2d3748';
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.rect(-15, -15, 30, 30); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-8, -8, 16, 16);
                    ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(22, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-22, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(0, 22); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(0, -22); ctx.stroke();
                } else if (this.isWraith) {
                    ctx.globalAlpha = 0.6 + Math.sin(gameState.frames * 0.2) * 0.3; 
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI*2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(0, 0); ctx.lineTo(-15, -10); ctx.lineTo(-15, 10);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                } else if (this.isMagma) {
                    ctx.fillStyle = '#7c2d12';
                    ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#ea580c';
                    ctx.beginPath(); ctx.arc(5, -5, 8, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(-5, 5, 6, 0, Math.PI*2); ctx.fill();
                } else if (this.isInferno) {
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); ctx.fill();
                    ctx.fillStyle = '#fcd34d';
                    ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
                } else if (this.isBoss) {
                    ctx.fillStyle = '#1a1a1a';
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(10, -10); ctx.lineTo(20, 0); ctx.lineTo(10, 10);
                    ctx.moveTo(-10, -10); ctx.lineTo(-20, 0); ctx.lineTo(-10, 10);
                    ctx.stroke();
                    const grad = ctx.createRadialGradient(0,0, 2, 0,0, 15);
                    grad.addColorStop(0, '#fff'); grad.addColorStop(1, this.color);
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.arc(0,0, 8, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillStyle = '#000';
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = this.color;
                    ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(4, 0); ctx.lineTo(12, 0); ctx.stroke();
                }

                if (this.burnTimer > 0) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#ff5500';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius + 2, 0, Math.PI*2); ctx.fill();
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
                
                if (gameState.healthBarsEnabled) {
                    const hp = Math.max(0, this.health / this.maxHealth);
                    const barWidth = this.radius * 2.5;
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 10, barWidth, 4);
                    
                    let hpColor = '#4ade80';
                    if (this.health < this.maxHealth * 0.3) hpColor = '#ef4444';
                    else if (this.health < this.maxHealth * 0.6) hpColor = '#fbbf24';
                    
                    ctx.fillStyle = hpColor;
                    ctx.fillRect(this.x - barWidth/2, this.y - this.radius - 10, barWidth * hp, 4);
                }
            }
        }

        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.level = 1;
                this.recalcStats();
                
                this.cooldown = 0;
                this.angle = 0;
                this.totalSpent = this.stats.cost; 
                this.heat = 0;
                this.maxHeat = 100;
                this.isOverheated = false;
                this.ammo = (type === 'orbital') ? 1 : -1;
                this.isGold = false;

                if (gameState.goldenTowers.includes(type)) {
                    this.applyGoldStats();
                }
            }

            recalcStats() {
                this.stats = { ...TOWERS[this.type] }

                if (this.level > 1) {
                     this.stats.damage = Math.floor(this.stats.damage * Math.pow(1.4, this.level - 1));
                     this.stats.range = Math.floor(this.stats.range * Math.pow(1.1, this.level - 1));
                }

                const techLvl = gameState.techLevels[this.type] || 0;
                if (techLvl > 0) {
                    this.stats.damage = Math.floor(this.stats.damage * (1 + techLvl * 0.1));
                }
            }

            applyGoldStats() {
                if (this.isGold) return;
                this.isGold = true;
                this.stats.damage = Math.floor(this.stats.damage * 1.5);
                this.stats.range = Math.floor(this.stats.range * 1.2);
                this.stats.color = '#FFD700';
            }

            update() {
                if(gameState.movingTowerInstance === this) return; 
                if(this.type === 'orbital') return; 

                if (this.type === 'vulkan') {
                    if (this.isOverheated) {
                        this.heat -= 0.5; 
                        if (this.heat <= 0) {
                            this.heat = 0;
                            this.isOverheated = false;
                        }
                    } else {
                        if (this.cooldown <= 0 && this.heat > 0) {
                             this.heat -= 1; 
                        }
                    }
                }

                if (this.cooldown > 0) this.cooldown--;
                if (this.isOverheated) return; 

                let target = null;
                
                if (this.type === 'pulse') {
                    if (this.cooldown <= 0) {
                        let enemyInRange = false;
                        for (let enemy of gameState.enemies) {
                            if (Math.hypot(enemy.x - this.x, enemy.y - this.y) <= this.stats.range) {
                                enemyInRange = true;
                                break;
                            }
                        }
                        if (enemyInRange) {
                            this.firePulse();
                            this.cooldown = this.stats.cooldown;
                        }
                    }
                    return;
                }

                let minDist = Infinity;
                
                for (let enemy of gameState.enemies) {
                    const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                    if (dist <= this.stats.range) {
                        if (dist < minDist) {
                            minDist = dist;
                            target = enemy;
                        }
                    }
                }

                if (target) {
                    this.angle = Math.atan2(target.y - this.y, target.x - this.x);

                    if (this.cooldown <= 0) {
                        this.shoot(target);
                        this.cooldown = this.stats.cooldown;
                    }
                }
            }

            firePulse() {
                gameState.projectiles.push({
                    x: this.x, y: this.y,
                    active: true,
                    type: 'wave',
                    radius: 1,
                    maxRadius: this.stats.range,
                    color: this.stats.color,
                    update: function() {
                        this.radius += 5;
                        if(this.radius >= this.maxRadius) this.active = false;
                        return !this.active;
                    },
                    draw: function() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1 - (this.radius / this.maxRadius);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                });

                gameState.enemies.forEach(enemy => {
                     if (Math.hypot(enemy.x - this.x, enemy.y - this.y) <= this.stats.range) {
                         damageEnemy(enemy, this.stats.damage);
                         enemy.burnTimer = 60;
                     }
                });
            }

            shoot(target) {
                if (this.type === 'tesla') {
                    this.fireTesla(target);
                } else if (this.type === 'vulkan') {
                    this.heat += 4;
                    if(this.heat >= this.maxHeat) {
                        this.isOverheated = true;
                        this.cooldown = 300; 
                    }
                    gameState.projectiles.push(new Projectile(this.x, this.y, target, this.stats, this.angle));
                    createExplosion(this.x + Math.cos(this.angle)*20, this.y + Math.sin(this.angle)*20, '#ffaa00', 5);
                } else {
                    gameState.projectiles.push(new Projectile(this.x, this.y, target, this.stats, this.angle));
                }
            }
            
            fireTesla(target) {
                let targets = [target];
                damageEnemy(target, this.stats.damage);
                createLightning(this.x, this.y, target.x, target.y, this.stats.color);

                for(let enemy of gameState.enemies) {
                    if(enemy === target) continue;
                    if(targets.length >= 3) break;
                    const dist = Math.hypot(enemy.x - target.x, enemy.y - target.y);
                    if(dist < 100) {
                        damageEnemy(enemy, this.stats.damage);
                        createLightning(target.x, target.y, enemy.x, enemy.y, this.stats.color);
                        targets.push(enemy);
                    }
                }
            }

            draw() {
                if(gameState.movingTowerInstance === this) return; 

                const size = 20;
                
                const baseGrad = ctx.createRadialGradient(this.x, this.y, 5, this.x, this.y, size);
                baseGrad.addColorStop(0, '#334155');
                baseGrad.addColorStop(1, '#0f172a');
                
                ctx.fillStyle = baseGrad;
                ctx.strokeStyle = '#475569';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.strokeStyle = this.isOverheated ? '#555' : this.stats.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size - 4, 0, Math.PI * 2);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.type !== 'pulse') ctx.rotate(this.angle);
                
                this.drawTurretHead();

                ctx.restore();

                ctx.fillStyle = '#fff';
                for(let i=0; i<this.level; i++) {
                    const lx = this.x - 6 + (i*5);
                    const ly = this.y + 24;
                    ctx.fillStyle = this.stats.color;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = this.stats.color;
                    ctx.fillRect(lx, ly, 3, 3);
                }
                ctx.shadowBlur = 0;

                if (this.isGold) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath(); ctx.arc(this.x + 15, this.y - 15, 4, 0, Math.PI*2); ctx.fill();
                }

                if (this.type === 'vulkan' && this.heat > 0) {
                    const heatPct = this.heat / this.maxHeat;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 15, this.y - 30, 30, 4);
                    
                    ctx.fillStyle = this.isOverheated ? '#ff0000' : '#ff5500';
                    ctx.fillRect(this.x - 15, this.y - 30, 30 * heatPct, 4);
                }

                if (this.type === 'orbital' && this.ammo > 0) {
                     ctx.shadowBlur = 10;
                     ctx.shadowColor = '#00ffff';
                     ctx.beginPath();
                     ctx.arc(this.x, this.y, 5, 0, Math.PI*2);
                     ctx.fillStyle = '#00ffff';
                     ctx.fill();
                     ctx.shadowBlur = 0;
                }

                if (gameState.selectedTowerInstance === this) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 25, 0, Math.PI*2);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    if (this.stats.range > 0) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI*2);
                        ctx.fillStyle = `rgba(255, 255, 255, 0.05)`;
                        ctx.fill();
                        ctx.strokeStyle = this.stats.color;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }

            drawTurretHead() {
                const color = this.isOverheated ? '#888' : this.stats.color;
                ctx.fillStyle = '#1e293b';
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.shadowBlur = this.isOverheated ? 0 : 10;
                ctx.shadowColor = color;

                if (this.type === 'basic') {
                    ctx.beginPath(); ctx.rect(-8, -8, 16, 16); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = color;
                    ctx.fillRect(0, -2, 22, 4);
                } 
                else if (this.type === 'cannon') {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, -6, 26, 12);
                    ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.strokeStyle = '#555'; ctx.strokeRect(0, -6, 26, 12);
                }
                else if (this.type === 'vulkan') {
                    ctx.fillStyle = this.isOverheated ? '#333' : '#4a1d1d';
                    ctx.fillRect(0, -5, 22, 10);
                    ctx.fillStyle = this.isOverheated ? '#555' : '#ff5500';
                    ctx.beginPath(); ctx.arc(22, 0, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(0, 0, 9, 0, Math.PI*2); 
                    ctx.fillStyle = '#222'; ctx.fill(); ctx.stroke();
                }
                else if (this.type === 'pulse') {
                    const pulse = Math.sin(gameState.frames * 0.1) * 3;
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(0,0, 12, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                    ctx.save();
                    ctx.rotate(gameState.frames * 0.05);
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 1.5); ctx.strokeStyle=color; ctx.stroke();
                    ctx.restore();
                    
                    ctx.save();
                    ctx.rotate(-gameState.frames * 0.05);
                    ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 1.5); ctx.strokeStyle='#fff'; ctx.stroke();
                    ctx.restore();

                    ctx.fillStyle = color;
                    ctx.shadowBlur = 15;
                    ctx.beginPath(); ctx.arc(0, 0, 4 + pulse * 0.2, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0;
                } 
                else if (this.type === 'sniper') {
                    ctx.fillStyle = '#111';
                    ctx.fillRect(0, -2, 35, 4); 
                    ctx.fillStyle = color;
                    ctx.fillRect(-10, -8, 20, 16); 
                    ctx.beginPath(); ctx.arc(15, 0, 3, 0, Math.PI*2); ctx.stroke(); 
                } 
                else if (this.type === 'minigun') {
                    ctx.fillStyle = '#222';
                    ctx.fillRect(-5, -10, 15, 20);
                    ctx.fillStyle = color;
                    ctx.fillRect(10, -8, 15, 2);
                    ctx.fillRect(10, 0, 15, 2);
                    ctx.fillRect(10, 6, 15, 2);
                } 
                else if (this.type === 'rocket') {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-10, -10, 20, 20);
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath();
                    ctx.moveTo(5, -5); ctx.lineTo(15, -5); ctx.lineTo(20, -8); ctx.lineTo(5, -8); ctx.fill();
                    ctx.moveTo(5, 5); ctx.lineTo(15, 5); ctx.lineTo(20, 8); ctx.lineTo(5, 8); ctx.fill();
                } 
                else if (this.type === 'tesla') {
                    ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(6, 0); ctx.lineTo(-6, 12); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI * 2); ctx.fill();
                } 
                else if (this.type === 'bombe') {
                    ctx.fillStyle = '#444';
                    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#a3e635';
                    ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-14); ctx.stroke();
                }
                else if (this.type === 'orbital') {
                    ctx.fillStyle = '#1e293b';
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#00ffff';
                    ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(14,0); ctx.lineTo(20,0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-14,0); ctx.lineTo(-20,0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0,14); ctx.lineTo(0,20); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(0,-20); ctx.stroke();
                }
            }
        }

        class Projectile {
            constructor(x, y, target, stats, initialAngle) {
                this.x = x; this.y = y; this.target = target; 
                this.tx = target.x; this.ty = target.y;
                this.stats = stats; 
                this.speed = this.stats.type === 'pulse' ? 14 : (this.stats.name === 'Minigun' ? 22 : 12); 
                this.active = true;
                this.isAoE = (stats.type === 'aoe' || stats.type === 'burn');
                this.angle = initialAngle;
                this.trail = [];
            }
            update() {
                if (gameState.particlesEnabled && this.frames % 2 === 0) {
                     this.trail.push({x: this.x, y: this.y, alpha: 1.0});
                }

                if (this.target && gameState.enemies.includes(this.target)) {
                    this.tx = this.target.x; this.ty = this.target.y;
                }
                const dx = this.tx - this.x;
                const dy = this.ty - this.y;
                const dist = Math.hypot(dx, dy);
                
                this.angle = Math.atan2(dy, dx);

                if (dist < this.speed) { this.hit(); return true; }
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
                return false;
            }
            hit() {
                if (this.stats.type === 'aoe') {
                    createExplosion(this.x, this.y, this.stats.color, 30);
                    gameState.enemies.forEach(enemy => {
                        if (Math.hypot(enemy.x - this.x, enemy.y - this.y) < this.stats.radius) {
                            damageEnemy(enemy, this.stats.damage);
                        }
                    });
                } else {
                    if (this.target && gameState.enemies.includes(this.target)) {
                        damageEnemy(this.target, this.stats.damage);
                        if(this.stats.type === 'slow') this.target.slowTimer = 60;
                        if(this.stats.type === 'burn') this.target.burnTimer = 180; 
                        createExplosion(this.x, this.y, this.stats.color, 8);
                    }
                }
                this.active = false;
            }
            draw() {
                if(this.type === 'wave') { this.draw(); return; } 

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                if (this.stats.name === 'Laser' || this.stats.name === 'Minigun') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.stats.color;
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, -1, 15, 2);
                    ctx.fillStyle = this.stats.color;
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(-5, -3, 25, 6);
                } 
                else if (this.stats.name === 'Cannon' || this.stats.name === 'Sniper') {
                     ctx.fillStyle = '#fff';
                     ctx.beginPath(); ctx.arc(0,0, 3, 0, Math.PI*2); ctx.fill();
                     ctx.strokeStyle = this.stats.color;
                     ctx.lineWidth = 2;
                     ctx.beginPath(); ctx.moveTo(-5, 0); ctx.lineTo(5, 0); ctx.stroke();
                }
                else if (this.stats.name === 'Rocket') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(-6, -3, 12, 6);
                    ctx.fillStyle = '#ef4444';
                    ctx.beginPath(); ctx.moveTo(6, -3); ctx.lineTo(12, 0); ctx.lineTo(6, 3); ctx.fill();
                    ctx.fillStyle = '#888';
                    ctx.fillRect(-8, -4, 4, 8);

                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath(); ctx.moveTo(-8, 0); ctx.lineTo(-15 - Math.random()*5, 0); ctx.lineTo(-8, 3); ctx.lineTo(-8, -3); ctx.fill();
                } 
                else if (this.stats.name === 'Bombe') {
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#a3e635'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(2, -2, 2, 0, Math.PI*2); ctx.fill();
                } 
                else if (this.stats.type === 'burn') {
                     ctx.shadowBlur = 5; ctx.shadowColor = '#f59e0b';
                     ctx.fillStyle = '#ffaa00';
                     ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
                     ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI*2); ctx.fill();
                } 
                else {
                    ctx.fillStyle = this.stats.color;
                    ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
                }
                
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const a = Math.random() * Math.PI * 2; const s = Math.random() * 3 + 1;
                this.vx = Math.cos(a) * s; this.vy = Math.sin(a) * s;
                this.life = 1.0; this.decay = Math.random() * 0.05 + 0.02;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= this.decay; return this.life <= 0;
            }
            draw() {
                ctx.globalAlpha = this.life; 
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
                ctx.fill(); 
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        function initGame() {
            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousemove', handleCanvasMove);
            window.addEventListener('keydown', (e) => { 
                if (e.key === "Escape") {
                    if (gameState.targetingMode) {
                        gameState.targetingMode = false;
                        document.body.classList.remove('targeting');
                        updateUI();
                    }
                    if(gameState.movingTowerInstance) {
                        gameState.movingTowerInstance = null; 
                        updateUI();
                    } else {
                        cancelBuild(); 
                        deselectTower();
                    }
                }
                if (e.key.match(/^[a-zA-Z]$/)) {
                    keyHistory.push(e.key.toUpperCase());
                    if (keyHistory.length > CHEAT_CODE.length) keyHistory.shift();
                    if (keyHistory.join('') === CHEAT_CODE) activateCheat();
                }
            });
            document.getElementById('startWaveBtn').addEventListener('click', startNextWave);
            initBuildMenu();
            loadGame();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        function initBuildMenu() {
            const menu = document.getElementById('buildMenu');
            menu.innerHTML = '';
            
            Object.keys(TOWERS).forEach(key => {
                const t = TOWERS[key];
                const isUnlocked = gameState.unlockedTowers.includes(key);
                
                const btn = document.createElement('button');
                btn.className = `tower-btn group relative flex flex-col items-center gap-1 p-2 rounded-lg w-20 h-28 justify-between ${isUnlocked ? '' : 'locked'}`;
                btn.id = `btn-${key}`;
                btn.onclick = () => handleTowerClick(key);
                btn.onmouseenter = () => showTowerInfo(t);
                btn.onmouseleave = hideTowerInfo;
                btn.style.setProperty('--glow-color', t.color);
                btn.style.color = t.color;

                let iconHtml = '';
                if(key === 'basic') iconHtml = `<div class="w-3 h-3 bg-cyan-400 rounded-full shadow-[0_0_10px_#00f3ff]"></div>`;
                else if(key === 'cannon') iconHtml = `<div class="w-4 h-4 border-2 border-purple-500 transform rotate-45"></div>`;
                else if(key === 'vulkan') iconHtml = `<div class="w-4 h-4 bg-orange-600 rounded-sm shadow-[0_0_10px_#ff5500]"></div>`;
                else if(key === 'plasma') iconHtml = `<div class="w-4 h-4 rounded-full border-2 border-yellow-400 animate-pulse"></div>`;
                else if(key === 'sniper') iconHtml = `<div class="w-1 h-5 bg-green-500"></div><div class="w-5 h-1 bg-green-500 absolute"></div>`;
                else if(key === 'minigun') iconHtml = `<div class="flex gap-0.5"><div class="w-1 h-3 bg-rose-500 rounded-full"></div><div class="w-1 h-3 bg-rose-500 rounded-full"></div><div class="w-1 h-3 bg-rose-500 rounded-full"></div></div>`;
                else if(key === 'tesla') iconHtml = `<svg viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg>`;
                else if(key === 'rocket') iconHtml = `<svg viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5"><path d="M12 2l-2 6h4l-2-6zm-2 6l-1 8h6l-1-8h-4zm-1 8l-2 4h8l-2-4h-4z"/></svg>`;
                else if(key === 'orbital') iconHtml = `<div class="w-6 h-6 border-2 border-cyan-400 rounded-full flex items-center justify-center animate-spin"><div class="w-2 h-2 bg-cyan-400 rounded-full"></div></div>`;
                else if(key === 'bombe') iconHtml = `<div class="w-4 h-4 bg-lime-500 rounded-full border-2 border-white"></div>`;

                btn.innerHTML = `
                    <div class="absolute top-1 right-1 text-[8px] text-yellow-500 opacity-0 group-hover:opacity-100 transition-opacity locked-icon">🔒</div>
                    <div class="tower-icon-wrapper">
                        <div class="tower-icon-bg"></div>
                        ${iconHtml}
                    </div>
                    <div class="text-[9px] font-bold tracking-wider">${t.name.toUpperCase()}</div>
                    <div class="text-[10px] font-mono leading-tight text-center bg-black/40 px-1 rounded w-full" id="cost-${key}">
                    <span class="text-yellow-400">${t.cost}$</span>
                    </div>
                `;
                menu.appendChild(btn);
            });
        }

        function showTowerInfo(tower) {
            const panel = document.getElementById('towerInfoPanel');
            document.getElementById('infoName').innerText = tower.name;
            document.getElementById('infoName').style.color = tower.color;
            document.getElementById('infoType').innerText = tower.type.toUpperCase();
            document.getElementById('infoDesc').innerText = tower.description;
            document.getElementById('infoDmg').innerText = tower.damage;
            document.getElementById('infoRange').innerText = tower.range;
            
            let speedText = "Moy.";
            if (tower.cooldown < 10) speedText = "Extrême";
            else if (tower.cooldown > 1000) speedText = "Manuel";
            else if (tower.cooldown < 40) speedText = "Rapide";
            else if (tower.cooldown > 90) speedText = "Lente";
            
            document.getElementById('infoSpeed').innerText = speedText;
            
            panel.classList.add('visible');
        }

        function hideTowerInfo() {
            document.getElementById('towerInfoPanel').classList.remove('visible');
        }

        function activateCheat() {
            gameState.money += 10000;
            gameState.worldUnlocked = true; 
            saveGame();
            updateUI();
            showToast("ADMIN ACCESS + WORLD 2");
            createExplosion(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2, '#FFD700', 50);
            keyHistory = [];
        }

        function resetGame() {
            localStorage.removeItem(STORAGE_KEY);
            gameState = {
                money: 200,
                lives: 25,
                shield: 0,
                shieldCost: 600,
                wave: 1,
                gameStarted: true,
                isPlaying: true,
                isGameOver: false,
                isPaused: false,
                autoWaveEnabled: false,
                volume: 0.5,
                gameSpeed: 1,
                particlesEnabled: true,
                healthBarsEnabled: true,
                difficultyMultiplier: 1.0,
                selectedTower: null,
                selectedTowerInstance: null,
                movingTowerInstance: null,
                targetingMode: false,
                unlockedTowers: ['basic'],
                goldenTowers: [],
                techLevels: {},
                enemies: [],
                towers: [],
                projectiles: [],
                particles: [],
                waveActive: false,
                waveEnemiesToSpawn: 0,
                waveSpawnTimer: 0,
                frames: 0,
                currentWorld: 1,
                worldUnlocked: false
            };
            Object.keys(TOWERS).forEach(k => gameState.techLevels[k] = 0);
            document.body.classList.remove('world-inferno');
            document.getElementById('overlay').classList.add('hidden');
            
            const knob = document.getElementById('autoWaveKnob');
            const btn = document.getElementById('autoWaveBtn');
            knob.style.left = '0.25rem';
            knob.classList.add('bg-white');
            knob.classList.remove('bg-green-400');
            btn.classList.remove('bg-slate-600');

            updateUI();
            initBuildMenu();
        }

        function startNextWave() {
            if (gameState.waveActive || gameState.isGameOver) return;

            if (gameState.wave % 5 === 0) {
                 const warning = document.getElementById('bossWarning');
                 warning.classList.remove('hidden');
                 setTimeout(() => warning.classList.add('hidden'), 3000);

                 setTimeout(() => {
                     launchWaveLogic();
                 }, 3000);
            } else {
                launchWaveLogic();
            }
        }
        
        function launchWaveLogic() {
            gameState.waveActive = true;
            gameState.waveEnemiesToSpawn = 5 + Math.floor(gameState.wave * 1.5);
            gameState.waveSpawnTimer = 0;
            
            gameState.towers.forEach(t => {
                if (t.type === 'orbital') t.ammo = 1;
            });

            cancelBuild();
            deselectTower();
            
            updateUI(); 
        }

        function damageEnemy(e, dmg) {
            e.health -= dmg;
            if (e.health <= 0) {
                rewardKill(e);
            }
        }
        
        function rewardKill(e) {
            let reward = 15;
            if(e.isBoss) reward = 60;
            if(e.isSpeeder) reward = 20;
            if(e.isTank) reward = 30;
            if(e.isTitan) reward = 100;
            if(e.isWraith) reward = 25;
            if(e.isMagma) reward = 40;
            if(e.isInferno) reward = 50;
            
            gameState.money += reward;
            createExplosion(e.x, e.y, e.color, 20);
            gameState.enemies = gameState.enemies.filter(en => en !== e);
            updateUI();
        }

        function createExplosion(x, y, c, n) {
            if(!gameState.particlesEnabled) return;
            for (let i = 0; i < n; i++) gameState.particles.push(new Particle(x, y, c));
        }
        
        function createLightning(x1, y1, x2, y2, color) {
            if(!gameState.particlesEnabled) return;
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            let midX = (x1 + x2) / 2 + (Math.random() - 0.5) * 30;
            let midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 30;
            ctx.lineTo(midX, midY);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        function checkCombatLock() {
            if (gameState.waveActive) {
                showToast("CONSTRUCTION VERROUILLÉE PENDANT LE COMBAT !");
                return true;
            }
            return false;
        }

        function handleTowerClick(type) {
            if (checkCombatLock()) return;

            if (type === 'orbital' && gameState.towers.some(t => t.type === 'orbital')) {
                showToast("LIMITE ATTEINTE : 1 ORBITAL MAX !");
                return;
            }
            
            deselectTower(); 
            if (gameState.unlockedTowers.includes(type)) {
                if (gameState.selectedTower === type) cancelBuild();
                else {
                    gameState.selectedTower = type;
                    document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('active'));
                    document.getElementById('btn-' + type).classList.add('active');
                }
            } else {
                showToast("DÉBLOQUER CETTE ARME DANS L'ARSENAL !");
                toggleArsenal();
            }
        }

        function cancelBuild() {
            gameState.selectedTower = null;
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('active'));
        }

        function deselectTower() {
            gameState.selectedTowerInstance = null;
            gameState.movingTowerInstance = null;
            gameState.targetingMode = false;
            document.body.classList.remove('targeting');
            updateUI();
        }

        function sellSelectedTower() {
            if (checkCombatLock()) return;
            if (!gameState.selectedTowerInstance) return;
            const t = gameState.selectedTowerInstance;
            gameState.money += Math.floor(t.totalSpent * 0.5); 
            gameState.towers = gameState.towers.filter(tower => tower !== t);
            
            createExplosion(t.x, t.y, '#ffd700', 30);
            showToast(`VENDU`);
            
            gameState.selectedTowerInstance = null;
            saveGame();
            updateUI();
        }

        function upgradeSelectedTower() {
            if (checkCombatLock()) return;
            const t = gameState.selectedTowerInstance;
            if(!t || t.level >= 5) return; 

            const cost = Math.floor(t.stats.cost * (t.level + 0.5)); 
            if(gameState.money >= cost) {
                gameState.money -= cost;
                t.level++;
                t.totalSpent += cost;
                t.recalcStats();
                
                createExplosion(t.x, t.y, '#00ff00', 20);
                showToast(`AMÉLIORATION NIVEAU ${t.level}!`);
                saveGame();
                updateUI();
            } else {
                showToast("Fonds insuffisants");
            }
        }

        function startMoveTower() {
            if (checkCombatLock()) return;
            if(!gameState.selectedTowerInstance) return;
            gameState.movingTowerInstance = gameState.selectedTowerInstance;
            gameState.selectedTowerInstance = null; 
            updateUI();
            showToast("CLIQUEZ SUR UN NOUVEL EMPLACEMENT");
        }

        function activateOrbitalMode() {
            if (gameState.selectedTowerInstance && gameState.selectedTowerInstance.type === 'orbital') {
                if (gameState.selectedTowerInstance.ammo <= 0) {
                     showToast("RECHARGE NÉCESSAIRE (ATTENDRE VAGUE SUIVANTE)");
                     return;
                }
                if (gameState.money < TOWERS.orbital.shotCost) {
                    showToast(`FONDS INSUFFISANTS (${TOWERS.orbital.shotCost}$ REQUIS)`);
                    return;
                }

                gameState.targetingMode = true;
                document.body.classList.add('targeting');
                showToast("CIBLAGE ACTIVÉ : CLIQUEZ POUR TIRER (500$)");
                updateUI();
            }
        }

        function fireOrbitalStrike(x, y) {
            const cost = TOWERS.orbital.shotCost;
            if (gameState.money < cost) {
                showToast("Fonds insuffisants !");
                gameState.targetingMode = false;
                document.body.classList.remove('targeting');
                updateUI();
                return;
            }

            gameState.money -= cost;
            createExplosion(x, y, '#00ffff', 100);
            
            gameState.enemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - x, enemy.y - y);
                if (dist < 150) {
                    damageEnemy(enemy, 5000); 
                }
            });

            if(gameState.selectedTowerInstance) {
                gameState.selectedTowerInstance.ammo = 0;
            }
            
            gameState.targetingMode = false;
            document.body.classList.remove('targeting');
            updateUI();
            showToast(`TIR ORBITAL EFFECTUÉ (-${cost}$)`);
        }

        function handleCanvasClick(e) {
            if (!gameState.gameStarted || gameState.isGameOver || gameState.isPaused) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (gameState.targetingMode) {
                fireOrbitalStrike(mouseX, mouseY);
                return;
            }

            if (gameState.movingTowerInstance) {
                if(canBuildAt(mouseX, mouseY, gameState.movingTowerInstance)) {
                    gameState.movingTowerInstance.x = mouseX;
                    gameState.movingTowerInstance.y = mouseY;
                    createExplosion(mouseX, mouseY, '#00ffff', 15);
                    gameState.movingTowerInstance = null;
                    saveGame();
                    updateUI();
                    showToast("TOUR DÉPLACÉE");
                } else {
                    showToast("Emplacement invalide");
                }
                return;
            }

            const clickedTower = gameState.towers.find(t => Math.hypot(t.x - mouseX, t.y - mouseY) < 25);
            if (clickedTower) {
                cancelBuild(); 
                gameState.selectedTowerInstance = clickedTower;
                updateUI();
                return;
            }

            if (gameState.selectedTower) {
                if (canBuildAt(mouseX, mouseY)) {
                    const cost = TOWERS[gameState.selectedTower].cost;
                    if (gameState.money >= cost) {
                        gameState.money -= cost;
                        gameState.towers.push(new Tower(mouseX, mouseY, gameState.selectedTower));
                        saveGame();
                        createExplosion(mouseX, mouseY, '#ffffff', 10);
                        updateUI();
                    } else {
                        showToast("Fonds insuffisants");
                    }
                } else {
                    showToast("Emplacement invalide");
                }
            } else {
                deselectTower();
            }
        }

        let mousePos = {x: 0, y: 0};
        function handleCanvasMove(e) {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        }

        function canBuildAt(x, y, ignoreTower = null) {
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i]; const p2 = path[i+1];
                const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
                if (l2 === 0) continue;
                let t = ((x - p1.x) * (p2.x - p1.x) + (y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const px = p1.x + t * (p2.x - p1.x); const py = p1.y + t * (p2.y - p1.y);
                if (Math.hypot(x - px, y - py) < 30) return false;
            }
            
            for (let t of gameState.towers) {
                if(t === ignoreTower) continue; 
                if (Math.hypot(t.x - x, t.y - y) < 45) return false;
            }
            
            if (x < 25 || x > CANVAS_WIDTH - 25 || y < 25 || y > CANVAS_HEIGHT - 25) return false;
            return true;
        }

        function showToast(msg) {
            const c = document.getElementById('toastContainer');
            const el = document.createElement('div');
            el.className = "bg-slate-800/90 text-blue-200 px-6 py-3 rounded-md shadow-xl text-sm font-bold animate-pulse border-l-4 border-blue-500 font-mono tracking-wide";
            el.innerText = `> ${msg}`; c.appendChild(el);
            setTimeout(() => el.remove(), 2500);
        }

        function updateUI() {
            document.getElementById('moneyDisplay').innerText = gameState.money;
            document.getElementById('livesDisplay').innerText = gameState.lives;
            document.getElementById('waveDisplay').innerText = gameState.wave;
            
            document.getElementById('enemiesLeftDisplay').innerText = gameState.enemies.length + gameState.waveEnemiesToSpawn;
            document.getElementById('shieldDisplay').innerText = Math.floor(gameState.shield);
            document.getElementById('shieldCostDisplay').innerText = gameState.shieldCost + "$";

            const hpPct = Math.min(100, Math.max(0, (gameState.lives / 25) * 100));
            document.getElementById('healthBarUI').style.width = `${hpPct}%`;

            const maxShield = 100;
            const shieldPct = Math.min(100, (gameState.shield / maxShield) * 100);
            document.getElementById('shieldBarUI').style.width = `${shieldPct}%`;

            const startBtn = document.getElementById('startWaveBtn');
            if (gameState.waveActive) {
                startBtn.disabled = true;
                startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                startBtn.innerText = "EN COURS...";
                document.getElementById('buildMenu').classList.add('combat-locked');
                document.getElementById('towerMenu').classList.add('combat-locked');
            } else {
                startBtn.disabled = false;
                startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                startBtn.innerText = "LANCER";
                document.getElementById('buildMenu').classList.remove('combat-locked');
                document.getElementById('towerMenu').classList.remove('combat-locked');
            }

            if (gameState.worldUnlocked && gameState.currentWorld === 1) {
                document.getElementById('btn-world').classList.remove('hidden');
            } else {
                document.getElementById('btn-world').classList.add('hidden');
            }

            const buildMenu = document.getElementById('buildMenu');
            const towerMenu = document.getElementById('towerMenu');
            const orbitalBtn = document.getElementById('orbitalActionBtn');

            if (gameState.selectedTowerInstance) {
                buildMenu.classList.add('hidden');
                buildMenu.classList.remove('flex');
                towerMenu.classList.remove('hidden');
                towerMenu.classList.add('flex');
                
                const t = gameState.selectedTowerInstance;
                document.getElementById('selectedTowerName').innerText = t.stats.name.toUpperCase();
                document.getElementById('selectedTowerName').style.color = t.stats.color;
                document.getElementById('towerLevelBadge').innerText = `Lvl ${t.level}`;
                
                const refund = Math.floor(t.totalSpent * 0.5);
                document.getElementById('sellRefundPrice').innerText = `+${refund}$`;

                const upgradeBtn = document.getElementById('upgradeBtn');
                if (t.level >= 5) {
                    upgradeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    document.getElementById('upgradeCost').innerText = "MAX";
                } else {
                    upgradeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    const cost = Math.floor(t.stats.cost * (t.level + 0.5));
                    document.getElementById('upgradeCost').innerText = `${cost}$`;
                }

                if (t.type === 'orbital') {
                    orbitalBtn.classList.remove('hidden');
                    if (t.ammo > 0) {
                        orbitalBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        orbitalBtn.querySelector('span:last-child').innerText = `TIRER ${TOWERS.orbital.shotCost}$`;
                    } else {
                        orbitalBtn.classList.add('opacity-50', 'cursor-not-allowed');
                        orbitalBtn.querySelector('span:last-child').innerText = "RECHARGE...";
                    }
                } else {
                    orbitalBtn.classList.add('hidden');
                }

            } else {
                buildMenu.classList.remove('hidden');
                buildMenu.classList.add('flex');
                towerMenu.classList.add('hidden');
                towerMenu.classList.remove('flex');
            }

            Object.keys(TOWERS).forEach(type => {
                const btn = document.getElementById('btn-' + type);
                if (!btn) return;
                const costDisplay = document.getElementById('cost-' + type);
                const lockIcon = btn.querySelector('.locked-icon');
                const isUnlocked = gameState.unlockedTowers.includes(type);
                const towerData = TOWERS[type];

                if (isUnlocked) {
                    btn.classList.remove('locked');
                    if (lockIcon) lockIcon.style.display = 'none';
                    costDisplay.innerHTML = `<span class="text-yellow-400">${towerData.cost}$</span>`;
                    
                    if (gameState.money < towerData.cost) {
                        btn.style.opacity = '0.5';
                        btn.classList.add('cursor-not-allowed');
                    } else {
                        btn.style.opacity = '1';
                        btn.classList.remove('cursor-not-allowed');
                    }
                } else {
                    btn.classList.add('locked');
                    if (lockIcon) lockIcon.style.display = 'block';
                    costDisplay.innerHTML = `
                    <span class="text-slate-400 font-bold text-[10px]">VERROUILLÉ</span>
                    `;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                }
            });
        }

        function gameOver() {
            gameState.isGameOver = true;
            gameState.isPlaying = false;
            localStorage.removeItem(STORAGE_KEY);
            
            document.getElementById('overlayTitle').innerText = "FIN DE TRANSMISSION";
            document.getElementById('overlayMessage').innerText = `Vous avez tenu jusqu'à la vague ${gameState.wave}.`;
            document.getElementById('overlay').classList.remove('hidden');
        }

        function drawPath() {
            ctx.shadowBlur = 10;
            ctx.shadowColor = gameState.currentWorld === 2 ? 'rgba(255, 66, 66, 0.3)' : 'rgba(66, 153, 225, 0.3)';
            ctx.strokeStyle = COLORS.pathBorder;
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
            ctx.stroke();
            
            ctx.strokeStyle = 'rgba(255,255,255,0.02)';
            ctx.lineWidth = 36;
            ctx.stroke();

            ctx.shadowBlur = 0;
            
            const dashOffset = -gameState.frames * 1.5;
            ctx.setLineDash([15, 25]);
            ctx.lineDashOffset = dashOffset;
            ctx.strokeStyle = gameState.currentWorld === 2 ? 'rgba(255, 100, 50, 0.3)' : 'rgba(100, 200, 255, 0.2)';
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.setLineDash([]);

            const start = path[0];
            const end = path[path.length-1];
            
            const g1 = ctx.createRadialGradient(start.x, start.y, 5, start.x, start.y, 30);
            g1.addColorStop(0, '#ff0055'); g1.addColorStop(1, 'transparent');
            ctx.fillStyle = g1;
            ctx.beginPath(); ctx.arc(start.x, start.y, 30, 0, Math.PI * 2); ctx.fill();

            const g2 = ctx.createRadialGradient(end.x, end.y, 5, end.x, end.y, 35);
            g2.addColorStop(0, '#3b82f6'); g2.addColorStop(1, 'transparent');
            ctx.fillStyle = g2;
            ctx.beginPath(); ctx.arc(end.x, end.y, 35, 0, Math.PI * 2); ctx.fill();

            if (gameState.shield > 0) {
                const shieldRadius = 45 + Math.sin(gameState.frames * 0.05) * 5;
                const shieldOpacity = Math.min(0.6, gameState.shield * 0.02);
                
                ctx.beginPath();
                ctx.arc(end.x, end.y, shieldRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.max(0.3, shieldOpacity)})`;
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(end.x, end.y, shieldRadius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.max(0.1, shieldOpacity * 0.5)})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.stroke();

                ctx.fillStyle = `rgba(0, 255, 255, ${Math.max(0.05, shieldOpacity * 0.2)})`;
                ctx.fill();
            }
        }
        
        let scanY = 0;
        let autoWaveTimer = 0;

        function gameLoop() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (!gameState.gameStarted) {
                scanY = (scanY + 2) % CANVAS_HEIGHT;
                ctx.fillStyle = `rgba(0, 150, 255, 0.02)`;
                ctx.fillRect(0, scanY, CANVAS_WIDTH, 5);
                drawPath();
                requestAnimationFrame(gameLoop);
                return;
            }

            scanY = (scanY + 2) % CANVAS_HEIGHT;
            ctx.fillStyle = gameState.currentWorld === 2 ? `rgba(255, 50, 0, 0.02)` : `rgba(0, 150, 255, 0.02)`;
            ctx.fillRect(0, scanY, CANVAS_WIDTH, 5);
            drawPath();

            if (gameState.isPaused) {
                gameState.towers.forEach(t => t.draw());
                gameState.enemies.forEach(e => e.draw());
                gameState.projectiles.forEach(p => p.draw());
                gameState.particles.forEach(p => p.draw());
                requestAnimationFrame(gameLoop);
                return;
            }

            for(let step = 0; step < gameState.gameSpeed; step++) {

                if (gameState.waveActive && !gameState.isGameOver) {
                    gameState.waveSpawnTimer++;
                    if (gameState.waveEnemiesToSpawn > 0 && gameState.waveSpawnTimer > 50) { 
                        
                        gameState.enemies.push(new Enemy(gameState.wave));
                        gameState.waveEnemiesToSpawn--;
                        gameState.waveSpawnTimer = 0;
                        updateUI();
                    } else if (gameState.waveEnemiesToSpawn === 0 && gameState.enemies.length === 0) {
                        gameState.waveActive = false;
                        
                        if (gameState.wave >= 30 && !gameState.worldUnlocked) {
                             gameState.worldUnlocked = true;
                             showToast("ACCÈS MONDE 2 DÉBLOQUÉ !");
                             updateUI();
                        }

                        gameState.wave++;
                        gameState.money += 100 + (gameState.wave * 25); 
                        
                        saveGame();

                        if(gameState.autoWaveEnabled) {
                            showToast("VAGUE SUIVANTE DANS 3s...");
                            autoWaveTimer = 180; 
                        } else {
                            showToast("VAGUE TERMINÉE");
                        }
                        
                        updateUI();
                    }
                }
                
                if (!gameState.waveActive && gameState.autoWaveEnabled && autoWaveTimer > 0 && !gameState.isGameOver) {
                    autoWaveTimer--;
                    if(autoWaveTimer <= 0) {
                        startNextWave();
                    }
                }

                gameState.towers.forEach(t => t.update());
                
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const e = gameState.enemies[i];
                    if (e.update()) {
                        
                        if (gameState.shield > 0) {
                            gameState.shield--;
                            createExplosion(e.x, e.y, '#00ffff', 20); 
                        } else {
                            const damage = e.isBoss ? 5 : (e.isTitan ? 10 : (e.isTank ? 2 : 1));
                            gameState.lives -= damage; 
                            if(step === 0) {
                                const overlay = document.createElement('div');
                                overlay.className = "fixed inset-0 bg-red-500/20 z-40 pointer-events-none";
                                document.body.appendChild(overlay);
                                setTimeout(() => overlay.remove(), 100);
                            }
                        }
                        
                        gameState.enemies.splice(i, 1); 
                        updateUI();
                        
                        if (gameState.lives <= 0) gameOver();
                    } else if (e.health <= 0) {
                         rewardKill(e);
                         gameState.enemies.splice(i, 1); 
                    }
                }

                for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                    const p = gameState.projectiles[i];
                    if (p.update) {
                        if (p.update()) gameState.projectiles.splice(i, 1);
                    } else {
                         if (p.update() || !p.active) gameState.projectiles.splice(i, 1);
                    }
                }

                for (let i = gameState.particles.length - 1; i >= 0; i--) {
                    const p = gameState.particles[i];
                    if (p.update()) gameState.particles.splice(i, 1);
                }
            }

            gameState.towers.forEach(t => t.draw());
            gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => p.draw());
            gameState.particles.forEach(p => p.draw());

            if (gameState.targetingMode) {
                const range = 150; 
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, range, 0, Math.PI * 2);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.moveTo(mousePos.x - 20, mousePos.y);
                ctx.lineTo(mousePos.x + 20, mousePos.y);
                ctx.moveTo(mousePos.x, mousePos.y - 20);
                ctx.lineTo(mousePos.x, mousePos.y + 20);
                ctx.strokeStyle = '#fff';
                ctx.stroke();
            }

            if (gameState.selectedTower && !gameState.isGameOver && !gameState.targetingMode && !gameState.waveActive) {
                const range = TOWERS[gameState.selectedTower].range;
                const color = TOWERS[gameState.selectedTower].color;
                ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, range, 0, Math.PI * 2);
                ctx.fillStyle = canBuildAt(mousePos.x, mousePos.y) ? `rgba(255, 255, 255, 0.1)` : `rgba(255, 0, 0, 0.2)`;
                ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
                ctx.fillStyle = color; ctx.globalAlpha = 0.5;
                ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, 10, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            if (gameState.movingTowerInstance && !gameState.isGameOver && !gameState.waveActive) {
                const t = gameState.movingTowerInstance;
                ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, t.stats.range, 0, Math.PI * 2);
                ctx.fillStyle = canBuildAt(mousePos.x, mousePos.y, t) ? `rgba(0, 255, 255, 0.1)` : `rgba(255, 0, 0, 0.2)`;
                ctx.fill();
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]);
                
                ctx.save();
                ctx.translate(mousePos.x, mousePos.y);
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = t.stats.color;
                ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
                ctx.globalAlpha = 1.0;
            }

            gameState.frames++;
            requestAnimationFrame(gameLoop);
        }

        initGame();
    </script>
</body>
</html>